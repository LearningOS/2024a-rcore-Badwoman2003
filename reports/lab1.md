# lab1

sys_task_info的实现要点有两个：1.统计syscall次数，2.统计距离第一次调用的时间

阅读Taksmanager源码时发现系统对任务的控制都由taskmanager提供的接口完成，于是选择在taskmanager实现两个新接口，分别用于syscall计数和统计时间

trap_handler在处理系统调用引起的中断时，会从寄存器a7（即x[17]）中取出系统调用号传给syscall()进行对应的调用，我们模仿这个方式在tcb中维护一个统计系统调用次数的数组，和taskinfo一样采取桶计数（原谅我想不出更好的数据结构了），每次trap_handler处理时都在当前任务的tcb中更新该系统调用的次数，这样sys_task_info也会被计入。

为了统计距离第一次被调度的时间，我在tcb中添加了两个成员变量：task_is_first和task_first_time，分别表示任务是否被初次调度以及初次调度的时间。当taskmanager调度一个任务时，会检查是否为初次调用，如是则更新时间。而sys_task_info调用时只需使用timer提供的接口get_time_ms()减去初次调用时间即可得到距离初次调度的时间



简答作业

1.三个bad测例的程序出错

bad_address：pagefault，程序试图访问非法地址0x0，内核强制中断该进程

bad_instructions：IllegalInstruction，程序试图使用s级指令sret

bad_register：IllegalInstruction，程序试图使用s级权限寄存器sstatus

使用sbi：RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0

2._alltraps和__restore作用

​	1.L40：a0通常代表系统调用的返回值。两个应用场景：1.系统调用返回，需要从内核态切换至用户态  2.上下文切换，内核使用taskmanager进行任务调度

​	2.L43-L48：

​		sstatus：保证当前进程是U特权级

​		spec：当前中断结束后的要执行的指令地址

​		sscratch：用于用户栈和内核栈的切换以及储存栈顶指针

​	3.L50-L60：riscv架构中，x2实际上是sp，x4实际上是tp，sp作为堆栈指针不需要恢复，tp为了线程安全也不需要恢复

​	4.L60：sp指向用户栈，sscratch指向内核栈

​	5.发生于sret 这条指令，之前 csrw sstatus, t0这条指令修改了sstatus的SPP为0，这样sret返回的即是用户态

​	6.L13：sp指向内核栈，sscratch指向用户栈

​	7.由硬件完成



荣誉准则：
1.在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

暂无

2.此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

代码暂无，简答题参考资料：https://lgl88911.github.io/2021/02/15/RISC-V%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%8A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E8%8C%83/

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。